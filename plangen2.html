<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>خطة حفظ القرآن الكريم التفصيلية</title> {/* تم تغيير العنوان قليلاً */}
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://www.gstatic.com/firebasejs/10.11.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore-compat.js"></script>

    <style>
        /* --- General Styles --- */
        body { font-family: 'Tajawal', sans-serif; direction: rtl; text-align: right; margin: 15px; background-color: #fdfdff; }
        h2, h3 { color: #1a5276; text-align: center; margin-bottom: 15px; }

        /* --- Input Form Area --- */
        /* #input-form-container is REMOVED from HTML, style is irrelevant now but kept for reference if needed */
        /* #input-form-container { background-color: #eaf2f8; padding: 20px 25px; border-radius: 8px; margin-bottom: 25px; border: 1px solid #aed6f1; display: none; } */
        /* ... other input styles ... */

        /* --- Hadith/Ayah Display Area --- */
        #quran-quote-container { display: none; text-align: center; margin: 30px auto; padding: 20px; font-family: 'Tajawal', sans-serif; font-size: 1.4em; color: #1a5276; background-color: #f6f9fc; border: 1px dashed #aed6f1; border-radius: 8px; max-width: 75%; }

        /* --- Action Buttons Area --- */
        .action-buttons { padding: 10px; text-align: left; display: none; /* Initially hidden */ }
        #print-button, #new-plan-btn { margin-right: 15px; padding: 10px 25px; font-size: 15px; font-weight: bold; color: white; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; font-family: 'Tajawal', sans-serif; }
        #print-button { background-color: #2980b9; } #print-button:hover { background-color: #3498db; }
        #new-plan-btn { background-color: #c0392b; } #new-plan-btn:hover { background-color: #e74c3c; }
        .clear { clear: both; }

        /* --- Summary Sections --- */
        #summary-container { margin-top: 25px; margin-bottom: 25px; display: none; /* Initially hidden */ }
        #data-sections { display: flex; align-items: stretch; justify-content: space-around; flex-wrap: wrap; background-color: #f8f9fa; padding: 10px; border-radius: 8px; border: 1px solid #dee2e6; gap: 15px; }
        #data-sections > div { flex: 1; min-width: 210px; padding: 15px 20px; background-color: #fff; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.08); display: flex; flex-direction: column; }
        #data-sections h3 { margin-top: 0; margin-bottom: 12px; border-bottom: 2px solid #1e8449; padding-bottom: 8px; font-size: 1.15em; color:#1a5276; }
        #data-sections > div > div { flex-grow: 1; }
        #data-sections p { margin: 6px 0; font-size: 0.98em; line-height: 1.6; font-family: 'Tajawal', sans-serif; }
        #data-sections p strong { color: #1a5276; margin-left: 5px; }
        #chart-container { display: flex; justify-content: center; align-items: center; min-height: 180px; padding-top: 10px; }
        #pieChart { max-width: 180px; max-height: 180px; }

        /* --- Table Styles --- */
        #table-container { overflow-x: auto; margin-top: 20px; display: none; /* Initially hidden */ border: 1.5px solid #6c757d; border-radius: 5px; }
        table { width: 100%; border-collapse: collapse; table-layout: auto; font-size: 12px; }
        th, td { border: 1px solid #8a9aab; padding: 5px 4px; text-align: center; vertical-align: middle; word-wrap: break-word; font-family: 'Tajawal', sans-serif; color: #1C1C1C; font-weight: normal; }
         td { font-weight: bold; } /* Note: This might make all td bold, consider if intended */
         tbody tr:nth-child(even):not(.completed-row):not(.excuse-holder-row) { background-color: #f8f9fa; }
         tbody tr:hover:not(.completed-row):not(.excuse-holder-row) { background-color: #eaf2f8; }
        th { background-color: #e4eaf1; font-weight: bold; font-size: 11.5px; position: sticky; top: 0; z-index: 10; color: #1a5276; border-bottom-width: 2px; border-bottom-color: #aed6f1; white-space: normal !important; }
        /* Varied Subtle Column Colors (TH only) */
        th:nth-child(1), th:nth-child(2), th:nth-child(3), th:nth-child(4) { background-color: #d1dbe5; } /* Group 1 */
        th:nth-child(5), th:nth-child(6), th:nth-child(7) { background-color: #d9e1e9; } /* Group 2 */
        th:nth-child(8), th:nth-child(9), th:nth-child(10), th:nth-child(11) { background-color: #e1e8ee; } /* Group 3 */
        th:nth-child(n+12) { background-color: #e4eaf1; } /* Default for rest */
        /* Cell Content Styles */
        select.excuse-select { width: 100%; box-sizing: border-box; font-size: 11px; padding: 4px 2px; border-color: #ccc; font-family: 'Tajawal', sans-serif; }
        td input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; vertical-align: middle; }
        td input[type="checkbox"]:disabled { cursor: not-allowed; opacity: 0.5; }
        /* Counter Button Styles */
        .button-group { display: flex; align-items: center; justify-content: center; }
        .button-group button { width: 20px; height: 20px; font-size: 14px; font-weight: bold; margin: 0 1px; cursor: pointer; transition: background-color 0.2s, transform 0.1s; border: 1px solid #ccc; background-color: #f8f8f8; color: #333; border-radius: 3px; padding: 0; line-height: 18px; font-family: 'Tajawal', sans-serif; }
        .button-group button:active { transform: translateY(1px); }
        .button-group button:disabled { background-color: #f0f0f0; color: #bbb; cursor: not-allowed; opacity: 0.7; }
        .button-group span { font-size: 13px; font-weight: bold; margin: 0 3px; min-width: 15px; display: inline-block; text-align: center; }
        /* Row States */
        .completed-row td { background-color: #d1e7dd !important; color: #0f5132; font-weight: bold; }
        .excuse-holder-row td { background-color: #f8d7da !important; font-style: italic; color: #58151c; }
        .excuse-holder-row td:nth-child(3) { font-weight: bold; font-style: normal; }
        .disabled-row { opacity: 0.7; }
        .disabled-row td:nth-child(3) { opacity: 1; pointer-events: auto; } /* Allow excuse selection */
        .disabled-row td:nth-child(3) select { pointer-events: auto; opacity: 1; } /* Allow excuse selection */
        .disabled-row .button-group button, .disabled-row input[type="checkbox"] { pointer-events: none; }
        /* Read-only styling */
        td.read-only { background-color: #f5f5f5; color: #444; font-weight: bold; }
        th.read-only { font-weight: bold; }
        /* Round colors */
        td.round-1 { background-color: #ffebee !important; } td.round-2 { background-color: #e8f5e9 !important; } td.round-3 { background-color: #e3f2fd !important; } td.round-4 { background-color: #fffde7 !important; } td.round-5 { background-color: #f3e5f5 !important; } td.round-6 { background-color: #e0f7fa !important; } td.round-1, td.round-2, td.round-3, td.round-4, td.round-5, td.round-6 { font-weight: bold; color: #333; }
        /* Delete Button */
        .delete-button { background-color: #e74c3c; color: white; border: none; width: 22px; height: 22px; border-radius: 50%; font-weight: bold; font-size: 12px; line-height: 22px; cursor: pointer; padding: 0; transition: background-color 0.3s; }
        .delete-button:hover { background-color: #c0392b; }
        .delete-button:disabled { background-color: #E5E7E9; cursor: not-allowed; }
         /* Loading Indicator */
         #loading-indicator { text-align: center; padding: 40px; font-size: 1.3em; color: #1a5276; display: none; /* Initially hidden */ }

        /* --- Print Specific Styles --- */
        @media print {
             body { margin: 5px; font-size: 10px; background-color: #fff; }
             #input-form-container, .action-buttons, #quran-quote-container, #summary-container h3, #chart-container, .delete-button, #new-plan-btn, #loading-indicator { display: none !important; }
             #summary-container { margin: 10px 0; }
             #data-sections { padding: 5px; border: 1px solid #ccc; gap: 10px; background-color: #fff; }
             #data-sections > div { padding: 5px 8px; box-shadow: none; border: 1px solid #eee; flex-basis: 23%; flex-grow: 1; min-width: 150px;}
             #data-sections h3 { font-size: 1.05em; padding-bottom: 3px; border-bottom: 1px solid #ccc; }
             #data-sections p { font-size: 0.9em; margin: 3px 0; line-height: 1.4; }
             #table-container { margin-top: 10px; overflow: visible; border: none;}
             table { font-size: 9px; table-layout: fixed; } /* Fixed layout for print */
             th, td { padding: 2px 3px; border: 1px solid #bbb; font-weight: normal !important; /* Remove bold for print data */ }
             th { font-size: 8.5px; background-color: #f0f0f0 !important; color: #000; white-space: normal !important; vertical-align: middle;}
             td.read-only { background-color: #fafafa; }
             .button-group button { display: none; } /* Hide counter buttons */
             .button-group span { font-size: 10px; } /* Show only the number */
             td input[type="checkbox"] { width: 10px; height: 10px; } /* Smaller checkboxes */
             select.excuse-select { display: none; } /* Hide excuse select */
             .excuse-holder-row td:nth-child(3)::before { content: attr(data-excuse); font-style: normal; font-weight: bold;} /* Show excuse text */
             .completed-row td { background-color: #e0ffe8 !important; color: #000; }
             .excuse-holder-row td { background-color: #ffebeb !important; font-style: normal; color: #000; }
             .round-1, .round-2, .round-3, .round-4, .round-5, .round-6 { background-color: inherit !important; /* Reset round colors for B&W */ }
             @page { size: A4 landscape; margin: 0.7cm; } /* Landscape for wider table */
        }

    </style>
</head>
<body>
    <div id="quran-quote-container">
        <p id="quran-quote-text"></p>
    </div>

    <div class="action-buttons">
        <button id="new-plan-btn">إنشاء جدول جديد</button> {/* This button might need review later */}
        <button id="print-button" onclick="printData()">طباعة الجدول</button>
    </div>
    <div class="clear"></div>

    <div id="summary-container">
         <h3>ملخص الخطة والإنجاز</h3>
        <div id="data-sections">
            <div> <h3>البيانات الأساسية</h3> <div id="data-section"></div> </div>
            <div> <h3>إحصائيات الحفظ</h3> <div id="memorized-section"></div> </div>
            <div> <h3>إحصائيات الإتقان والربط</h3> <div id="followup-section"></div> </div>
            <div> <h3>رسم بياني</h3> <div id="chart-container"> <canvas id="pieChart"></canvas> </div> </div>
        </div>
    </div>

    <div id="table-container">
        <table id="customTable">
             <thead>
                 <tr>
                     <th>التسلسل</th><th>التاريخ</th><th>الأعذار</th><th>تكرار الأمس</th><th>من الصفحة</th><th>إلى الصفحة</th><th>السورة</th><th>الاستماع</th><th>التفسير</th><th>التسجيل</th><th>التكرار</th><th>الربط من</th><th>الربط إلى</th><th>مربوط</th><th>المراجعة من</th><th>المراجعة إلى</th><th>رقم الجولة</th><th>مراجع</th><th>إتمام اليوم</th><th>حذف</th>
                 </tr>
             </thead>
             <tbody></tbody>
        </table>
    </div>

    <div id="loading-indicator"> جاري تحميل بيانات الخطة... </div>


    <script src="https://www.gstatic.com/firebasejs/10.11.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore-compat.js"></script>

    <script>
        // --- Global Variables & Config ---
        const initialTotalRows = 320; // Base rows for initial calculation, might not be strictly needed if tableRows dictates length
        const initialTotalDays = 300; // Base days for summary calculation
        let pieChartInstance;
        const totalQuranPages = 604;
        let currentUser = null; // Store current logged-in user
        let currentPlanData = null; // Store loaded plan data from Firestore (includes tableRows array)
        let isSaving = false; // Flag to prevent concurrent saves
        // Keep track of total rows based on loaded data for summary calculation
        let currentTotalRows = 0;
        let currentTotalDays = 0;


        // Firebase Config (Keep as provided)
        const firebaseConfig = {
         apiKey: "AIzaSyDuUebu7Qzz3JnTfa-58EIPZjOcrkmdGHU",
         authDomain: "quranplan2.firebaseapp.com",
         projectId: "quranplan2",
         storageBucket: "quranplan2.appspot.com",
         messagingSenderId: "1098692856811",
         appId: "1:1098692856811:web:923bca3a54fd78b1b267ae"
        };

        // --- Initialize Firebase ---
         try {
             firebase.initializeApp(firebaseConfig);
         } catch (e) {
              console.error("Firebase initialization error:", e);
              alert("حدث خطأ أثناء تهيئة الاتصال بالخادم.");
         }
        const auth = firebase.auth();
        const db = firebase.firestore();

        // --- DOM Element References ---
        // const inputContainer = document.getElementById('input-form-container'); // REMOVED
        const quoteContainer = document.getElementById('quran-quote-container');
        const quoteText = document.getElementById('quran-quote-text');
        const actionButtonsContainer = document.querySelector('.action-buttons');
        const printButton = document.getElementById('print-button');
        const newPlanBtn = document.getElementById('new-plan-btn');
        const summaryContainer = document.getElementById('summary-container');
        const tableContainer = document.getElementById('table-container');
        const tableBody = document.querySelector('#customTable tbody');
        // const generateBtn = document.getElementById('generateBtn'); // REMOVED
        const loadingIndicator = document.getElementById('loading-indicator');

        // --- Data Arrays (Keep as provided) ---
        const surahs = ['الفاتحة والبقرة', 'البقرة', /* ... Sura data ... */ 'ختم القرآن'];
        const linkFromData = ['', '', 1,1, /* ... Link data ... */ 577];
        const linkToData = ['', '', 2,4, /* ... Link data ... */ 604];
        const reviewFromData = [...Array(32).fill(''), 1,3, /* ... Review data ... */ 481];
        const reviewToData = [...Array(32).fill(''), 2,4, /* ... Review data ... */ 576];
        const quranQuotes = [ /* ... Quotes data ... */ ];

        // --- Utility Functions (Keep as provided) ---
        function formatDate(date) { if (!(date instanceof Date)) { date = new Date(date); } if (isNaN(date.getTime())) { return "تاريخ غير صالح"; } const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, '0'); const day = String(date.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; }
        function getPlanData(originalIndex) { const index = parseInt(originalIndex); if (isNaN(index) || index < 0 || index >= initialTotalRows) { /* Adjusted logic: Maybe base index limit on currentPlanData.tableRows.length? Needs care. */ return { fromPage: '', toPage: '', surah: '', linkFrom: '', linkTo: '', reviewFrom: '', reviewTo: '', round: '' }; } let fromPage = '', toPage = ''; if (index < 299) { fromPage = index * 2 + 1; toPage = fromPage + 1; } else if (index === 299) { fromPage = 601; toPage = 604; } /* This part might need adjustment if plan structure changes */ return { fromPage: fromPage, toPage: toPage, surah: surahs[index] || '', linkFrom: linkFromData[index] ?? '', linkTo: linkToData[index] ?? '', reviewFrom: reviewFromData[index] ?? '', reviewTo: reviewToData[index] ?? '', round: calculateRoundNumber(index) }; }
        function calculateRoundNumber(originalIndex) { if (originalIndex < 32 || reviewFromData[originalIndex] == null || reviewFromData[originalIndex] === '') { return ''; } let reviewDataStartIndex = 32; let reviewCounter = 0; for(let i = reviewDataStartIndex; i <= originalIndex; i++){ if(reviewFromData[i] != null && reviewFromData[i] !== '') reviewCounter++; } if (reviewCounter === 0) return ''; return Math.ceil(reviewCounter / 6); }

        // --- Helper functions for creating cell content (Keep as provided) ---
        function createReadOnlyCell(value, classes = []) { const cell = document.createElement('td'); cell.textContent = value ?? ''; cell.classList.add('read-only', ...classes); return cell; }
        function createCounter(initialValue, maxValue, callback) { const container = document.createElement('div'); container.className = 'button-group'; const maxVal = parseInt(maxValue) || 0; const minusButton = document.createElement('button'); minusButton.textContent = '-'; const plusButton = document.createElement('button'); plusButton.textContent = '+'; const valueSpan = document.createElement('span'); valueSpan.textContent = initialValue; minusButton.onclick = function() { let cv = parseInt(valueSpan.textContent); if (cv > 0) { cv--; valueSpan.textContent = cv; if(callback) callback(); } }; plusButton.onclick = function() { let cv = parseInt(valueSpan.textContent); if (cv < maxVal) { cv++; valueSpan.textContent = cv; if(callback) callback(); } }; container.appendChild(plusButton); container.appendChild(valueSpan); container.appendChild(minusButton); return container; }
        function createCounterCell(initialValue, maxValue, callback) { const cell = document.createElement('td'); const counter = createCounter(initialValue, maxValue, callback); cell.appendChild(counter); return cell; }
        function createCheckbox(callback) { const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.onclick = callback; return checkbox; }
        function createCheckboxCell(callback, addCheckbox = true) { const cell = document.createElement('td'); if (addCheckbox) { cell.appendChild(createCheckbox(callback)); } return cell; }
        function createExcuseSelect(rowRef) { const excusesSelect = document.createElement('select'); excusesSelect.classList.add('excuse-select'); const options = [ { text: '', value: '' }, { text: 'مرض', value: 'مرض' }, { text: 'امتحانات', value: 'امتحانات' }, { text: 'انشغال', value: 'انشغال' }, { text: 'طارئ', value: 'طارئ' }, { text: 'نسيان', value: 'نسيان' }]; options.forEach(function(od) { const op = document.createElement('option'); op.textContent = od.text; op.value = od.value; excusesSelect.appendChild(op); }); excusesSelect.onchange = function() { if (this.value !== '') { if (confirm(`هل أنت متأكد من تسجيل عذر "${this.value}" لهذا اليوم؟ سيتم ترحيل الخطة وحفظ التقدم.`)) { handleExcuseSelection(rowRef, this.value); } this.selectedIndex = 0; } }; return excusesSelect; }
        function createDeleteButton(rowRef) { const deleteButton = document.createElement('button'); deleteButton.textContent = 'X'; deleteButton.classList.add('delete-button'); deleteButton.title = 'حذف العذر وإعادة اليوم'; deleteButton.onclick = function() { if (confirm('هل أنت متأكد من حذف هذا العذر؟ سيتم حفظ التقدم.')) { deleteExcuse(rowRef); } }; return deleteButton; }

        // --- Enabling/Disabling (Keep as provided) ---
        function disableElement(cell) { if (!cell) return; const bg = cell.querySelector('.button-group'); const cb = cell.querySelector('input[type="checkbox"]'); if (bg) { bg.querySelectorAll('button').forEach(btn => btn.disabled = true); } else if (cb) { cb.disabled = true; } }
        function enableElement(cell) { if (!cell) return; const bg = cell.querySelector('.button-group'); const cb = cell.querySelector('input[type="checkbox"]'); if (bg) { bg.querySelectorAll('button').forEach(btn => btn.disabled = false); } else if (cb) { cb.disabled = false; } }
        function deactivateRow(row) { if (!row || row.classList.contains('excuse-holder-row')) return; row.classList.add('disabled-row'); for (let i = 3; i <= 18; i++) { if (row.cells[i]) { disableElement(row.cells[i]); } } if(row.cells[2]) { /* Allow excuse selection even if deactivated */ row.cells[2].style.opacity = 1; row.cells[2].style.pointerEvents = 'auto'; const s = row.cells[2].querySelector('select'); if(s) s.disabled = false; } }
        function activateRow(row) { if (!row || row.classList.contains('excuse-holder-row')) return; row.classList.remove('disabled-row'); if (row.cells[3]) { enableElement(row.cells[3]); } /* Only enable Yesterday's Rep */ for (let i = 7; i <= 18; i++) { /* Keep others disabled initially */ if (row.cells[i]) { disableElement(row.cells[i]); } } if(row.cells[2]) { row.cells[2].style.opacity = 1; row.cells[2].style.pointerEvents = 'auto'; const s = row.cells[2].querySelector('select'); if(s) s.disabled = false; } validateSequence(row); /* Validate sequence will enable subsequent elements correctly */ }

        // --- Validation Sequence Logic (Keep as provided) ---
        // IMPORTANT: This function relies on `currentPlanData.repetitionMax`. Ensure `currentPlanData` is set correctly before this runs.
        function validateSequence(row) {
             if (!row || row.classList.contains('disabled-row') || row.classList.contains('excuse-holder-row')) { return; }
             // Ensure currentPlanData is loaded before accessing repetitionMax
             const repMaxVal = (currentPlanData && currentPlanData.repetitionMax) ? currentPlanData.repetitionMax : 20; // Default to 20 if not loaded yet
             const yRepCell = row.cells[3]; const listCell = row.cells[7]; const intCell = row.cells[8]; const recCell = row.cells[9]; const repCell = row.cells[10]; const linkCell = row.cells[13]; const revCell = row.cells[17]; const compCell = row.cells[18]; const yVal = yRepCell?.querySelector('span') ? parseInt(yRepCell.querySelector('span').textContent) : 0; const listVal = listCell?.querySelector('span') ? parseInt(listCell.querySelector('span').textContent) : 0; const intChk = intCell?.querySelector('input') ? intCell.querySelector('input').checked : false; const recVal = recCell?.querySelector('span') ? parseInt(recCell.querySelector('span').textContent) : 0; const repVal = repCell?.querySelector('span') ? parseInt(repCell.querySelector('span').textContent) : 0; const linkEx = linkCell?.querySelector('input') !== null; const linkChk = linkEx && linkCell.querySelector('input').checked; const revEx = revCell?.querySelector('input') !== null; const revChk = revEx && revCell.querySelector('input').checked;
             let allowNext = false; let enList = yVal >= 5; enList ? enableElement(listCell) : disableElement(listCell); if (enList) allowNext = listVal >= 1; else allowNext = false; let enInt = allowNext; enInt ? enableElement(intCell) : disableElement(intCell); if (enInt) allowNext = intChk; else allowNext = false; let enRec = allowNext; enRec ? enableElement(recCell) : disableElement(recCell); if (enRec) allowNext = recVal >= 1; else allowNext = false; let enRep = allowNext; enRep ? enableElement(repCell) : disableElement(repCell); if (enRep) allowNext = repVal >= repMaxVal; else allowNext = false; let enLink = allowNext; if(linkCell) { enLink ? enableElement(linkCell) : disableElement(linkCell); } if (enLink && linkEx) allowNext = linkChk; else if (enLink && !linkEx) allowNext = true; else allowNext = false; let enRev = allowNext; if(revCell) { enRev ? enableElement(revCell) : disableElement(revCell); } if (enRev && revEx) allowNext = revChk; else if (enRev && !revEx) allowNext = true; else allowNext = false; let enComp = allowNext; if(compCell) { enComp ? enableElement(compCell) : disableElement(compCell); }
        }

        // --- Firestore Interaction Functions ---

        // Function to get the current state of the table from the DOM into savable array format (Keep as provided)
        function getCurrentTableStateArray() {
             const rows = tableBody.querySelectorAll('tr');
             const tableRowsData = [];
             rows.forEach(row => {
                 const rowData = {
                     type: row.classList.contains('excuse-holder-row') ? 'excuse' : 'plan',
                     originalSequence: parseInt(row.dataset.originalSequence),
                     displaySeq: parseInt(row.cells[0]?.textContent || '0'),
                     displayDate: row.cells[1]?.textContent || '',
                     state: null // Initialize state
                 };

                 if (rowData.type === 'plan' && row.cells.length > 18) {
                     const yestRepSpan = row.cells[3]?.querySelector('span');
                     const listenSpan = row.cells[7]?.querySelector('span');
                     const interpCheck = row.cells[8]?.querySelector('input[type="checkbox"]');
                     const recordSpan = row.cells[9]?.querySelector('span');
                     const repSpan = row.cells[10]?.querySelector('span');
                     const linkedCheck = row.cells[13]?.querySelector('input[type="checkbox"]');
                     const reviewedCheck = row.cells[17]?.querySelector('input[type="checkbox"]');
                     const completedCheck = row.cells[18]?.querySelector('input[type="checkbox"]');
                     rowData.state = {
                         yestRep: yestRepSpan ? parseInt(yestRepSpan.textContent) : 0,
                         listen: listenSpan ? parseInt(listenSpan.textContent) : 0,
                         interp: interpCheck?.checked ?? false,
                         record: recordSpan ? parseInt(recordSpan.textContent) : 0,
                         rep: repSpan ? parseInt(repSpan.textContent) : 0,
                         linked: linkedCheck?.checked ?? false,
                         reviewed: reviewedCheck?.checked ?? false,
                         completed: completedCheck?.checked ?? false
                     };
                 } else if (rowData.type === 'excuse') {
                     rowData.excuseType = row.cells[2]?.textContent || 'عذر';
                 }
                 tableRowsData.push(rowData);
             });
             return tableRowsData;
        }

        // Debounce mechanism for saving (Keep as provided)
        let saveTimeout;
        const DEBOUNCE_DELAY = 1500;

        // Function to save the current table state to Firestore (Debounced) (Keep as provided, but ensure currentPlanData has basic info)
        function saveCurrentTableState(isInitialSave = false) {
             clearTimeout(saveTimeout);
             if (!isInitialSave) {
                 console.log("Debouncing save...");
                 saveTimeout = setTimeout(() => {
                     performSave(false);
                 }, DEBOUNCE_DELAY);
             } else {
                 performSave(true); // Perform initial save immediately only if explicitly requested (e.g., maybe after adding first excuse?)
             }
        }

        // Actual function performing the save operation (Keep as provided, relies on global currentPlanData for basic info)
        async function performSave(isInitialSave) {
            if (!currentUser || isSaving) {
                console.warn("Save aborted. No user or already saving.", { currentUser, isSaving });
                return;
            }
            // Ensure basic plan data is available before saving
            if (!currentPlanData || !currentPlanData.startDate || !currentPlanData.repetitionMax) {
                console.error("Cannot save: Basic plan data (startDate, repetitionMax) is missing from currentPlanData.");
                // Optionally alert the user or try to recover, but saving without this is problematic.
                // For now, just prevent save.
                return;
            }

            const uid = currentUser.uid;
            const planRef = db.collection("quranPlans").doc(uid);

            isSaving = true;
            console.log(`Performing ${isInitialSave ? 'initial' : 'update'} save...`);

            try {
                const tableRows = getCurrentTableStateArray();

                // Use basic data from the globally loaded currentPlanData
                const dataToSave = {
                    studentName: currentPlanData.studentName || "طالب العلم", // Get from loaded data
                    startDate: currentPlanData.startDate,         // Get from loaded data
                    repetitionMax: currentPlanData.repetitionMax,     // Get from loaded data
                    tableRows: tableRows, // The current state from the DOM
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                };

                // createdAt should only be set once, ideally by index.html
                // We might add it here defensively if it's missing, but primary save is update.
                if (isInitialSave && !currentPlanData.createdAt) { // Only set createdAt if truly initial AND missing
                     dataToSave.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                     await planRef.set(dataToSave, { merge: true }); // Use merge:true for safety on initial set? Or just set().
                     console.log("Initial plan structure saved successfully (potentially merged).");
                 } else {
                     await planRef.update(dataToSave);
                     console.log("Plan state updated successfully.");
                 }

                // Update local cache WITH the data structure Firestore uses (including timestamps if needed)
                // Fetching the doc again after save might be safer but slower.
                // For now, update with what we intended to save.
                currentPlanData = { ...currentPlanData, ...dataToSave, tableRows: tableRows }; // Update local cache

            } catch (error) {
                console.error("Error saving plan state:", error);
                // alert("حدث خطأ أثناء حفظ التقدم. قد لا يتم حفظ آخر التغييرات."); // Maybe too intrusive on auto-save
            } finally {
                 isSaving = false;
                 console.log("Save operation finished.");
            }
        }


        // Function to delete plan data from Firestore (MODIFIED: Redirect to index.html)
        async function deletePlanData() {
             if (!currentUser) { alert("يرجى تسجيل الدخول أولاً."); return; }
             const uid = currentUser.uid;
             const planRef = db.collection("quranPlans").doc(uid);
             try {
                 await planRef.delete();
                 console.log("Plan data deleted successfully for user:", uid);
                 currentPlanData = null;
                 // Instead of showing creation form, redirect to index page
                 alert("تم حذف الخطة بنجاح. سيتم توجيهك لصفحة البداية.");
                 window.location.href = 'index.html'; // Redirect to index page
             } catch (error) {
                 console.error("Error deleting plan data:", error);
                 alert("حدث خطأ أثناء حذف الجدول القديم.");
             }
        }


        // --- Table Rendering Function (From Saved Data) (Keep mostly as provided) ---
        // This function now becomes the primary way the table is populated.
        function renderSavedTable(savedPlanData) {
            console.log("Rendering table from saved data...");
            tableBody.innerHTML = '';
            const savedRows = savedPlanData.tableRows || [];
            const repetitionMax = savedPlanData.repetitionMax || 20;

            // Set global state immediately
            currentPlanData = savedPlanData;

            // Recalculate total rows/days based on the actual loaded rows for summary
            currentTotalRows = savedRows.length;
            const excuseCount = savedRows.filter(row => row.type === 'excuse').length;
            // Assuming initialTotalDays was the base for non-excuse days
            currentTotalDays = initialTotalDays + excuseCount; // Adjust if initialTotalDays isn't the right base


            let previousRowCompleted = true; // Assume start is possible or previous was completed/excuse

            savedRows.forEach((rowData, index) => {
                const row = document.createElement('tr');
                row.dataset.originalSequence = rowData.originalSequence !== undefined ? rowData.originalSequence : -1;

                row.appendChild(createReadOnlyCell(rowData.displaySeq));
                row.appendChild(createReadOnlyCell(rowData.displayDate));

                if (rowData.type === 'plan' && rowData.state) {
                    row.classList.toggle('completed-row', rowData.state.completed);
                    const planInfo = getPlanData(rowData.originalSequence); // Get static data (pages, sura, etc.)

                    row.appendChild(document.createElement('td')).appendChild(createExcuseSelect(row)); // Excuse Select
                    row.appendChild(createCounterCell(rowData.state.yestRep, 5, () => { validateSequence(row); saveCurrentTableState(); })); // YestRep
                    row.appendChild(createReadOnlyCell(planInfo.fromPage));
                    row.appendChild(createReadOnlyCell(planInfo.toPage));
                    row.appendChild(createReadOnlyCell(planInfo.surah));
                    row.appendChild(createCounterCell(rowData.state.listen, 3, () => { validateSequence(row); saveCurrentTableState(); })); // Listen
                    const interpCell = createCheckboxCell(() => { validateSequence(row); saveCurrentTableState(); });
                    const interpCheck = interpCell.querySelector('input'); if (interpCheck) interpCheck.checked = rowData.state.interp; row.appendChild(interpCell); // Interp
                    row.appendChild(createCounterCell(rowData.state.record, 3, () => { validateSequence(row); saveCurrentTableState(); })); // Record
                    row.appendChild(createCounterCell(rowData.state.rep, repetitionMax, () => { validateSequence(row); saveCurrentTableState(); })); // Rep
                    row.appendChild(createReadOnlyCell(planInfo.linkFrom));
                    row.appendChild(createReadOnlyCell(planInfo.linkTo));
                    const linkedCell = createCheckboxCell(() => { validateSequence(row); saveCurrentTableState(); }, planInfo.linkTo !== '');
                    const linkedCheck = linkedCell.querySelector('input'); if (linkedCheck) linkedCheck.checked = rowData.state.linked; row.appendChild(linkedCell); // Linked
                    const rf_n = createReadOnlyCell(planInfo.reviewFrom); const rt_n = createReadOnlyCell(planInfo.reviewTo); row.appendChild(rf_n); row.appendChild(rt_n); const rd_n = createReadOnlyCell(planInfo.round); if (planInfo.round !== '') { const rc = `round-${((planInfo.round - 1) % 6 + 1)}`; rf_n.classList.add(rc); rt_n.classList.add(rc); rd_n.classList.add(rc); } row.appendChild(rd_n); // Review/Round
                    const reviewedCell = createCheckboxCell(() => { validateSequence(row); saveCurrentTableState(); }, planInfo.reviewTo !== '');
                    const reviewedCheck = reviewedCell.querySelector('input'); if (reviewedCheck) reviewedCheck.checked = rowData.state.reviewed; row.appendChild(reviewedCell); // Reviewed
                    const comp_n = createCheckboxCell(() => {
                        const isChecked = comp_n.querySelector('input').checked;
                        row.classList.toggle('completed-row', isChecked);
                        saveCurrentTableState(); // Save on completion change
                        const nextRow = row.nextElementSibling;
                        if (isChecked && nextRow) {
                            activateRow(nextRow);
                        } else if (!isChecked && nextRow && !nextRow.classList.contains('excuse-holder-row')) {
                            const nextCompCheck = nextRow.cells[18]?.querySelector('input');
                            if (!nextCompCheck || !nextCompCheck.checked) { // Only deactivate if next isn't already complete
                                deactivateRow(nextRow);
                            }
                        }
                        updateSummary(); // Update summary on completion change
                    }, true);
                    const completedCheck = comp_n.querySelector('input'); if (completedCheck) completedCheck.checked = rowData.state.completed; row.appendChild(comp_n); // Completion
                    row.appendChild(document.createElement('td')); // Empty delete cell for plan rows

                    // Activation logic based on previous row's completion status *in the saved data*
                    if (previousRowCompleted) {
                        activateRow(row); // Activate if previous was complete or it's the first row
                    } else {
                        deactivateRow(row); // Deactivate if previous was not complete
                    }
                    validateSequence(row); // Ensure correct enable/disable based on loaded state within the row itself
                    previousRowCompleted = rowData.state.completed; // Set for the next iteration

                } else if (rowData.type === 'excuse') {
                    row.classList.add('excuse-holder-row');
                    const excuseCell = row.appendChild(document.createElement('td'));
                    excuseCell.textContent = rowData.excuseType || 'عذر'; // Excuse Type
                    excuseCell.setAttribute('data-excuse', rowData.excuseType || 'عذر'); // For print styles
                    for (let k = 3; k <= 18; k++) { row.appendChild(document.createElement('td')); } // Empty cells
                    row.appendChild(document.createElement('td')).appendChild(createDeleteButton(row)); // Delete Button
                    previousRowCompleted = true; // Excuses allow the next row to be active

                } else {
                     console.warn("Unknown or invalid row type/state in saved data:", rowData);
                     // Render a placeholder or skip
                }
                tableBody.appendChild(row);
            });

             updateSummary(); // Update summary after rendering full table
             hideLoading(); // Hide loading indicator
        }

        // --- UI Control Functions (Keep as provided, but remove displayPlanCreationForm) ---
        function showLoading(message = "جاري التحميل...") { if (loadingIndicator) { loadingIndicator.textContent = message; loadingIndicator.style.display = 'block'; } hideMainContent(); } // Simplified hideMainContent call
        function hideLoading() { if (loadingIndicator) loadingIndicator.style.display = 'none'; }
        function hideMainContent() { /* Removed hideForm logic as form is gone */ if(quoteContainer) quoteContainer.style.display = 'none'; if(actionButtonsContainer) actionButtonsContainer.style.display = 'none'; if(summaryContainer) summaryContainer.style.display = 'none'; if(tableContainer) tableContainer.style.display = 'none'; }
        // function displayPlanCreationForm() { ... } // REMOVED
        function displayExistingPlanUI() { hideLoading(); /* inputContainer gone */ if(quoteContainer) quoteContainer.style.display = 'block'; if(actionButtonsContainer) actionButtonsContainer.style.display = 'block'; if(summaryContainer) summaryContainer.style.display = 'block'; if(tableContainer) tableContainer.style.display = 'block'; const randomQuoteIndex = Math.floor(Math.random() * quranQuotes.length); if(quoteText) quoteText.textContent = quranQuotes[randomQuoteIndex]; }

        // --- Main Application Flow (REMOVED loadUserPlan - logic moved to Auth Listener) ---
        // function loadUserPlan(user) { ... } // REMOVED

        // --- Event Listeners ---
        // generateBtn listener REMOVED
        // if (generateBtn) { ... } // REMOVED

        // Keep New Plan button listener logic, but deletePlanData now redirects
        function attachNewPlanListener() { if (newPlanBtn) { newPlanBtn.removeEventListener('click', handleNewPlanClick); newPlanBtn.addEventListener('click', handleNewPlanClick); } }
        function handleNewPlanClick() { if (confirm("هل أنت متأكد أنك تريد حذف الجدول الحالي وإنشاء جدول جديد؟ لن تتمكن من استعادة الجدول القديم وسيتم توجيهك لصفحة البداية.")) { deletePlanData(); } }

        // --- Auth Listener (MODIFIED) ---
        auth.onAuthStateChanged(user => {
            // Keep hiding loading indicator until auth state is known
            // hideLoading(); // Moved hiding inside the logic paths

            if (user) {
                currentUser = user;
                console.log("Auth state changed: User is logged in.", user.uid);

                // --- Load Plan Data Here ---
                const uid = user.uid;
                const planRef = db.collection("quranPlans").doc(uid);
                console.log("Checking Firestore for plan:", uid);
                showLoading("جاري تحميل بيانات خطتك..."); // Show loading specific to data fetch

                planRef.get().then((doc) => {
                    if (doc.exists) {
                        console.log("Plan data found in Firestore.");
                        const planData = doc.data();
                        currentPlanData = planData; // Set global variable

                        // Validate necessary data exists before rendering
                        if (planData.tableRows && Array.isArray(planData.tableRows) && planData.tableRows.length > 0 && planData.startDate && planData.repetitionMax) {
                            renderSavedTable(planData); // Render table from saved state
                            displayExistingPlanUI(); // Show table, summary, etc.
                            // updateSummary() is called inside renderSavedTable
                            attachNewPlanListener(); // Attach listener for delete button
                        } else {
                            // Handle incomplete data - critical info missing
                            console.error("Plan data is incomplete (missing tableRows, startDate, or repetitionMax). Please recreate plan.");
                            hideLoading();
                            alert("بيانات الخطة غير مكتملة أو تالفة. يرجى الذهاب لصفحة البداية وإعادة إنشاء الخطة.");
                            window.location.href = 'index.html'; // Redirect to index page
                        }
                    } else {
                        // No plan document found for this user
                        console.log("No plan data found in Firestore. Redirecting to index.");
                        hideLoading();
                        alert("لم يتم العثور على خطة. سيتم توجيهك لإنشاء خطة جديدة.");
                        window.location.href = 'index.html'; // Redirect to index page
                    }
                }).catch((error) => {
                    console.error("Error getting plan document:", error);
                    hideLoading();
                    alert("حدث خطأ أثناء تحميل بيانات الخطة. حاول تحديث الصفحة أو العودة لصفحة البداية.");
                    // Consider redirecting or offering retry
                });
                // --- End Load Plan Data ---

            } else {
                // User is logged out
                currentUser = null;
                console.log("Auth state changed: User is logged out.");
                hideLoading(); // Hide loading if shown during auth check
                hideMainContent(); // Hide everything
                // Show logged-out message or redirect
                document.body.innerHTML = '<div style="text-align: center; padding: 50px; font-size: 1.2em;">يرجى <a href="login.html">تسجيل الدخول</a> للوصول لهذه الصفحة.</div>';
            }
        });

        // --- Initial Setup on Load (Keep as provided) ---
        document.addEventListener('DOMContentLoaded', () => {
             hideMainContent(); // Hide main sections initially
             showLoading("جاري التحقق من تسجيل الدخول..."); // Show loading until auth state known
             // Auth listener (onAuthStateChanged) will take over
        });

        // --- Utility and Helper Functions (Keep as before, including summary updates) ---
        function updateSummary() { updateDataSection(); updateMemorizedSection(); updateFollowUpSection(); updatePieChart(); }
        function updateDataSection() { const dataSection = document.getElementById('data-section'); if (!currentPlanData || !currentPlanData.startDate) { dataSection.innerHTML = `<p>لم يتم تحميل بيانات الخطة.</p>`; return; } const studentName = currentPlanData.studentName || "طالب العلم"; const startDateValue = currentPlanData.startDate; const startDate = new Date(startDateValue + 'T00:00:00Z'); if (isNaN(startDate.getTime())) { dataSection.innerHTML = `<p>تاريخ البدء غير صالح.</p>`; return; } let initialEndDate = new Date(startDate); initialEndDate.setUTCDate(startDate.getUTCDate() + initialTotalDays - 1); const excuseRowsCount = document.querySelectorAll('#customTable tbody tr.excuse-holder-row').length; const currentDaysCalculated = (initialTotalDays + excuseRowsCount); /* Use calculated for end date */ let actualEndDate = new Date(startDate); actualEndDate.setUTCDate(startDate.getUTCDate() + currentDaysCalculated - 1); const today = new Date(); today.setUTCHours(0, 0, 0, 0); let remainingDays = 0; let actualEndDateUTC = new Date(actualEndDate); actualEndDateUTC.setUTCHours(0,0,0,0); if (actualEndDateUTC >= today) { remainingDays = Math.ceil((actualEndDateUTC.getTime() - today.getTime()) / (1000 * 3600 * 24)); } else { remainingDays = 0; /* Or indicate completion */ } dataSection.innerHTML = `<p><strong>اسم الطالب:</strong> ${studentName}</p><p><strong>تاريخ البدء:</strong> ${formatDate(startDate)}</p><p><strong>الانتهاء الأولي:</strong> ${formatDate(initialEndDate)}</p><p><strong>الانتهاء المتوقع:</strong> ${formatDate(actualEndDate)}</p><p><strong>أيام الأعذار:</strong> ${excuseRowsCount}</p><p><strong>الأيام المتبقية:</strong> ${remainingDays}</p>`;}
        function updateMemorizedSection() { const memorizedSection = document.getElementById('memorized-section'); const tableRows = document.querySelectorAll('#customTable tbody tr:not(.excuse-holder-row)'); let lmp = 0; tableRows.forEach(row => { const cc = row.cells[18]?.querySelector('input[type="checkbox"]'); const tc = row.cells[5]; if (cc?.checked && tc?.textContent) { const tp = parseInt(tc.textContent); if (!isNaN(tp) && tp > lmp) { lmp = tp; } } }); lmp = Math.min(lmp, totalQuranPages); const rm = totalQuranPages - lmp; memorizedSection.innerHTML = `<p><strong>الصفحات المحفوظة:</strong> ${lmp}</p><p><strong>الصفحات غير المحفوظة:</strong> ${rm}</p>`;}
        function updateFollowUpSection() { const followupSection = document.getElementById('followup-section'); const tableRows = document.querySelectorAll('#customTable tbody tr:not(.excuse-holder-row)'); let lpp = 0; let llp = 0; let cr = '-'; tableRows.forEach(row => { const lc = row.cells[13]?.querySelector('input[type="checkbox"]'); const rc = row.cells[17]?.querySelector('input[type="checkbox"]'); const ltc = row.cells[12]; const rtc = row.cells[15]; const rdc = row.cells[16]; if (lc?.checked && ltc?.textContent) { const lt = parseInt(ltc.textContent); if (!isNaN(lt) && lt > llp) llp = lt; } if (rc?.checked && rtc?.textContent) { const rt = parseInt(rtc.textContent); if (!isNaN(rt) && rt > lpp) { lpp = rt; if(rdc?.textContent && rdc.textContent.trim() !== '') cr = rdc.textContent; } } }); llp = Math.min(llp, totalQuranPages); lpp = Math.min(lpp, totalQuranPages); const rl = totalQuranPages - llp; const rp = totalQuranPages - lpp; followupSection.innerHTML = `<p><strong>الصفحات المربوطة:</strong> ${llp} <span style="font-size:0.8em;">(المتبقي: ${rl})</span></p><p><strong>الصفحات المتقنة:</strong> ${lpp} <span style="font-size:0.8em;">(المتبقي: ${rp})</span></p><p><strong>الجولة الحالية:</strong> ${cr}</p>`;}
        function updatePieChart() { const tableRows = document.querySelectorAll('#customTable tbody tr:not(.excuse-holder-row)'); let lmp = 0; let lpp = 0; tableRows.forEach(row => { const cc = row.cells[18]?.querySelector('input[type="checkbox"]'); const tc = row.cells[5]; const revc = row.cells[17]?.querySelector('input[type="checkbox"]'); const revtc = row.cells[15]; if (cc?.checked && tc?.textContent) { const tp = parseInt(tc.textContent); if (!isNaN(tp) && tp > lmp) lmp = tp; } if (revc?.checked && revtc?.textContent) { const rt = parseInt(revtc.textContent); if (!isNaN(rt) && rt > lpp) lpp = rt; } }); lmp = Math.min(lmp, totalQuranPages); lpp = Math.min(lpp, totalQuranPages); lpp = Math.min(lpp, lmp); /* Perfected cannot exceed memorized */ const perfected = lpp; const memorizedNotPerfected = Math.max(0, lmp - perfected); const notMemorized = Math.max(0, totalQuranPages - lmp); const ctx = document.getElementById('pieChart')?.getContext('2d'); if (!ctx) return; const data = { labels: ['متقن', 'محفوظ', 'غير محفوظ'], datasets: [{ data: [perfected, memorizedNotPerfected, notMemorized], backgroundColor: ['#28a745', '#ffc107', '#dc3545'], borderColor: '#fff', borderWidth: 1, hoverOffset: 4 }] }; if (window.pieChartInstance) { window.pieChartInstance.destroy(); } if (perfected === 0 && memorizedNotPerfected === 0 && notMemorized === 0 && totalQuranPages > 0) { const ca = document.getElementById('pieChart'); const co = ca.getContext('2d'); co.clearRect(0, 0, ca.width, ca.height); co.textAlign = 'center'; co.fillStyle = '#6c757d'; co.font = '13px Tajawal'; co.fillText('لا توجد بيانات بعد', ca.width / 2, ca.height / 2); window.pieChartInstance = null; } else if (perfected >= 0 && memorizedNotPerfected >= 0 && notMemorized >= 0) { window.pieChartInstance = new Chart(ctx, { type: 'doughnut', data: data, options: { responsive: true, maintainAspectRatio: false, cutout: '50%', plugins: { legend: { position: 'bottom', labels: { font: { size: 11, family: 'Tajawal' } } }, tooltip: { bodyFont: { family: 'Tajawal' }, callbacks: { label: function(ctx) { let l = ctx.label||''; if(l) l+=': '; const v = ctx.parsed||0; l += v + ' صفحة'; const t = ctx.dataset.data.reduce((a,b)=>a+b, 0); const p = t>0?((v/t)*100).toFixed(0)+'%':'0%'; l+=` (${p})`; return l; } } } } } }); } }

        // --- Excuse/Delete/Shift functions (Keep as provided, they rely on DOM and call saveCurrentTableState) ---
        function handleExcuseSelection(row, excuseValue) {
             const tableBody = document.querySelector('#customTable tbody'); const rowIndex = Array.from(tableBody.rows).indexOf(row); if (rowIndex === -1) return; const originalSequence = parseInt(row.dataset.originalSequence); const originalDate = new Date(row.cells[1].textContent + 'T00:00:00Z'); if (isNaN(originalDate.getTime())) { console.error("Invalid date in excuse row"); return; }
             row.classList.add('excuse-holder-row'); row.classList.remove('disabled-row', 'completed-row'); const planIndices = [4, 5, 6, 11, 12, 14, 15, 16]; planIndices.forEach(idx => { if(row.cells[idx]) row.cells[idx].textContent = ''; }); const interactiveIndices = [3, 7, 8, 9, 10, 13, 17, 18]; interactiveIndices.forEach(idx => { const c = row.cells[idx]; if(c){ const co = c.querySelector('.button-group'); const ch = c.querySelector('input[type="checkbox"]'); if(co) c.removeChild(co); if(ch) c.removeChild(ch); c.textContent = ''; disableElement(c); c.style.pointerEvents = 'none'; } }); const excuseCell = row.cells[2]; excuseCell.textContent = excuseValue; excuseCell.style.fontWeight = 'bold'; excuseCell.setAttribute('data-excuse', excuseValue); const sel = excuseCell.querySelector('select'); if (sel) excuseCell.removeChild(sel);
             const deleteCell = row.cells[19]; if (deleteCell) { deleteCell.innerHTML = ''; const deleteButton = createDeleteButton(row); deleteCell.appendChild(deleteButton); } else { console.error("Delete cell not found."); }
             // Create and insert the new row for the shifted day
             const newRow = document.createElement('tr'); const shiftedSeq = originalSequence; newRow.dataset.originalSequence = shiftedSeq; const newDate = new Date(originalDate); newDate.setUTCDate(originalDate.getUTCDate() + 1); const planDataNew = getPlanData(shiftedSeq); const repMax = (currentPlanData && currentPlanData.repetitionMax) ? currentPlanData.repetitionMax : 20;
             const newSeqCell = document.createElement('td'); newRow.appendChild(newSeqCell); // Sequence cell, number set later
             newRow.appendChild(createReadOnlyCell(formatDate(newDate))); // New date
             const newExcCell = document.createElement('td'); newExcCell.appendChild(createExcuseSelect(newRow)); newRow.appendChild(newExcCell); // Excuse select
             // Add all interactive cells, initialized to 0/false
             newRow.appendChild(createCounterCell(0, 5, () => { validateSequence(newRow); saveCurrentTableState(); })); // YestRep
             newRow.appendChild(createReadOnlyCell(planDataNew.fromPage)); newRow.appendChild(createReadOnlyCell(planDataNew.toPage)); newRow.appendChild(createReadOnlyCell(planDataNew.surah)); // Plan info
             newRow.appendChild(createCounterCell(0, 3, () => { validateSequence(newRow); saveCurrentTableState(); })); // Listen
             newRow.appendChild(createCheckboxCell(() => { validateSequence(newRow); saveCurrentTableState(); })); // Interp
             newRow.appendChild(createCounterCell(0, 3, () => { validateSequence(newRow); saveCurrentTableState(); })); // Record
             newRow.appendChild(createCounterCell(0, repMax, () => { validateSequence(newRow); saveCurrentTableState(); })); // Rep
             newRow.appendChild(createReadOnlyCell(planDataNew.linkFrom)); newRow.appendChild(createReadOnlyCell(planDataNew.linkTo)); // Link info
             newRow.appendChild(createCheckboxCell(() => { validateSequence(newRow); saveCurrentTableState(); }, planDataNew.linkTo !== '')); // Linked checkbox
             const rf_n = createReadOnlyCell(planDataNew.reviewFrom); const rt_n = createReadOnlyCell(planDataNew.reviewTo); newRow.appendChild(rf_n); newRow.appendChild(rt_n); const rd_n = createReadOnlyCell(planDataNew.round); if (planDataNew.round !== '') { const rc = `round-${((planDataNew.round - 1) % 6 + 1)}`; rf_n.classList.add(rc); rt_n.classList.add(rc); rd_n.classList.add(rc); } newRow.appendChild(rd_n); // Review info
             newRow.appendChild(createCheckboxCell(() => { validateSequence(newRow); saveCurrentTableState(); }, planDataNew.reviewTo !== '')); // Reviewed checkbox
             const comp_n = createCheckboxCell(() => { const ich = comp_n.querySelector('input').checked; newRow.classList.toggle('completed-row', ich); saveCurrentTableState(); const nxr = newRow.nextElementSibling; if (ich && nxr) activateRow(nxr); else if (!ich && nxr && !nxr.classList.contains('excuse-holder-row')) { const nc = nxr.cells[18]?.querySelector('input'); if(!nc || !nc.checked) deactivateRow(nxr); } updateSummary(); }, true); newRow.appendChild(comp_n); // Completion checkbox
             newRow.appendChild(document.createElement('td')); // Empty delete cell placeholder
             tableBody.insertBefore(newRow, row.nextSibling); // Insert the new row

             // Renumber and shift dates AFTER inserting the new row
             shiftRowsMetaDataForward(rowIndex + 1); // Shift starting from the inserted row

             // Activate/Deactivate the new row based on the state of the excuse row (which is now considered 'complete' for flow)
             // Since the excuse row allows flow, the new row should be active.
             activateRow(newRow);

             saveCurrentTableState(); // Save the entire new state (important!)
             updateSummary();
        }
        function deleteExcuse(excuseHolderRow) {
             const tableBody = document.querySelector('#customTable tbody'); const rowIndex = Array.from(tableBody.rows).indexOf(excuseHolderRow); if (rowIndex === -1 || !excuseHolderRow.classList.contains('excuse-holder-row')) return;
             tableBody.removeChild(excuseHolderRow);
             shiftRowsMetaDataBack(rowIndex); // Shift back starting from the row index where deletion occurred

             // Re-evaluate activation of the row now at the deleted index
             const rowNowAtIndex = tableBody.rows[rowIndex];
             const rowBefore = tableBody.rows[rowIndex - 1];
             if (rowNowAtIndex && !rowNowAtIndex.classList.contains('excuse-holder-row')) {
                 if (!rowBefore || rowBefore.classList.contains('completed-row') || rowBefore.classList.contains('excuse-holder-row') || rowIndex === 0) {
                     activateRow(rowNowAtIndex);
                 } else {
                     deactivateRow(rowNowAtIndex);
                 }
                 // Ensure subsequent rows are correctly deactivated if needed
                 let currentRow = rowNowAtIndex;
                 while(currentRow && currentRow.nextElementSibling) {
                     const next = currentRow.nextElementSibling;
                     if (currentRow.classList.contains('completed-row') || currentRow.classList.contains('excuse-holder-row')) {
                          if (!next.classList.contains('excuse-holder-row')) activateRow(next);
                     } else {
                          if (!next.classList.contains('excuse-holder-row')) deactivateRow(next);
                          break; // Stop deactivating chain
                     }
                     currentRow = next;
                 }
             }

             saveCurrentTableState(); // Save after deletion and shifting
             updateSummary();
        }
        function shiftRowsMetaDataBack(startIndex, direction = -1) {
             const tableBody = document.querySelector('#customTable tbody'); const rows = Array.from(tableBody.rows); console.log(`Shifting metadata back starting from index ${startIndex}`);
             for (let i = startIndex; i < rows.length; i++) {
                 const row = rows[i];
                 const sequenceCell = row.cells[0];
                 if (sequenceCell) {
                      const currentDisplaySeq = parseInt(sequenceCell.textContent);
                      if (!isNaN(currentDisplaySeq)) { sequenceCell.textContent = currentDisplaySeq + direction; }
                      else { console.warn(`Row ${i} missing sequence.`); }
                 }
                 // Shift date only for non-excuse rows
                 if (!row.classList.contains('excuse-holder-row')) {
                      const dateCell = row.cells[1];
                      if (dateCell) {
                           try { const currentDate = new Date(dateCell.textContent + 'T00:00:00Z'); currentDate.setUTCDate(currentDate.getUTCDate() + direction); dateCell.textContent = formatDate(currentDate); } catch (e) { console.error("Error updating date backward", i, e); }
                      }
                 }
             } console.log(`Finished shifting metadata back.`);
             // Update global row/day counts after shifting
              currentTotalRows = rows.length;
              const excuseCount = Array.from(tableBody.querySelectorAll('tr.excuse-holder-row')).length;
              currentTotalDays = initialTotalDays + excuseCount; // Recalculate based on new excuse count
        }
        function shiftRowsMetaDataForward(startIndex, direction = 1) {
            const tableBody = document.querySelector('#customTable tbody'); const rows = Array.from(tableBody.rows); console.log(`Shifting metadata forward starting from index ${startIndex}`);
            for (let i = startIndex; i < rows.length; i++) {
                const row = rows[i];
                const sequenceCell = row.cells[0];
                 if (sequenceCell) {
                     const currentDisplaySeq = parseInt(sequenceCell.textContent);
                     if (!isNaN(currentDisplaySeq)) { sequenceCell.textContent = currentDisplaySeq + direction; }
                     else { /* Try to infer from previous row if possible */
                         const prevRowSeqCell = rows[i-1]?.cells[0];
                         if(prevRowSeqCell) {
                            const prevSeq = parseInt(prevRowSeqCell.textContent);
                            if (!isNaN(prevSeq)) sequenceCell.textContent = prevSeq + direction;
                         } else {
                             console.warn(`Row ${i} missing sequence and cannot infer.`);
                         }
                     }
                 }
                // Shift date only for non-excuse rows
                 if (!row.classList.contains('excuse-holder-row')) {
                     const dateCell = row.cells[1];
                     if (dateCell) {
                          try { const currentDate = new Date(dateCell.textContent + 'T00:00:00Z'); currentDate.setUTCDate(currentDate.getUTCDate() + direction); dateCell.textContent = formatDate(currentDate); } catch (e) { console.error("Error updating date forward", i, e); }
                     }
                 }
            } console.log(`Finished shifting metadata forward.`);
            // Update global row/day counts after shifting
             currentTotalRows = rows.length;
             const excuseCount = Array.from(tableBody.querySelectorAll('tr.excuse-holder-row')).length;
             currentTotalDays = initialTotalDays + excuseCount; // Recalculate based on new excuse count
        }

        // --- Print Function (Keep as provided) ---
        function printData() {
             // Add data-excuse attribute for printing excuse text
             document.querySelectorAll('.excuse-holder-row').forEach(row => {
                 const excuseText = row.cells[2]?.textContent || '';
                 if(row.cells[2]) row.cells[2].setAttribute('data-excuse', excuseText);
             });
             console.log("Initiating browser print...");
             window.print();
         }

    </script>

</body>
</html>